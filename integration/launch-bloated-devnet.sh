#!/bin/bash
#
# Launch an Ethereum devnet with pre-populated state using ethereum-package
#
# Usage:
#   ./launch-bloated-devnet.sh [options]
#
# Options:
#   --accounts N        Number of EOA accounts (default: 10000)
#   --contracts N       Number of contracts (default: 5000)
#   --max-slots N       Max storage slots per contract (default: 10000)
#   --min-slots N       Min storage slots per contract (default: 100)
#   --distribution D    Storage distribution: power-law|uniform|exponential (default: power-law)
#   --seed N            Random seed for reproducibility (default: random)
#   --state-url URL     Download pre-generated state from URL instead of generating
#   --geth-nodes N      Number of geth nodes (default: 2)
#   --lighthouse-nodes N Number of lighthouse nodes (default: 2)
#   --output-dir DIR    Output directory for generated data (default: ./devnet-data)
#   --binary-trie       Generate state for binary trie mode (EIP-7864)
#   --skip-generation   Skip state generation (use existing state)
#   --help              Show this help

set -euo pipefail

# Default values
ACCOUNTS=10000
CONTRACTS=5000
MAX_SLOTS=10000
MIN_SLOTS=100
DISTRIBUTION="power-law"
SEED=""
STATE_URL=""
GETH_NODES=2
LIGHTHOUSE_NODES=2
OUTPUT_DIR="./devnet-data"
BINARY_TRIE=false
SKIP_GENERATION=false
ETHEREUM_PACKAGE_PATH="${ETHEREUM_PACKAGE_PATH:-$HOME/tools/ethereum-package}"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log_info() { echo -e "${GREEN}[INFO]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

usage() {
    sed -n '3,20p' "$0" | sed 's/^# //' | sed 's/^#//'
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --accounts) ACCOUNTS="$2"; shift 2 ;;
        --contracts) CONTRACTS="$2"; shift 2 ;;
        --max-slots) MAX_SLOTS="$2"; shift 2 ;;
        --min-slots) MIN_SLOTS="$2"; shift 2 ;;
        --distribution) DISTRIBUTION="$2"; shift 2 ;;
        --seed) SEED="$2"; shift 2 ;;
        --state-url) STATE_URL="$2"; shift 2 ;;
        --geth-nodes) GETH_NODES="$2"; shift 2 ;;
        --lighthouse-nodes) LIGHTHOUSE_NODES="$2"; shift 2 ;;
        --output-dir) OUTPUT_DIR="$2"; shift 2 ;;
        --binary-trie) BINARY_TRIE=true; shift ;;
        --skip-generation) SKIP_GENERATION=true; shift ;;
        --help) usage ;;
        *) log_error "Unknown option: $1"; usage ;;
    esac
done

# Check dependencies
check_deps() {
    local missing=()
    command -v docker &>/dev/null || missing+=("docker")
    command -v kurtosis &>/dev/null || missing+=("kurtosis")
    
    if [[ ${#missing[@]} -gt 0 ]]; then
        log_error "Missing dependencies: ${missing[*]}"
        log_info "Install with:"
        [[ " ${missing[*]} " =~ " docker " ]] && echo "  - Docker: https://docs.docker.com/get-docker/"
        [[ " ${missing[*]} " =~ " kurtosis " ]] && echo "  - Kurtosis: curl -fsSL https://get.kurtosis.io | bash"
        exit 1
    fi
}

# Generate or download state
prepare_state() {
    local state_dir="$OUTPUT_DIR/chaindata"
    
    if [[ "$SKIP_GENERATION" == "true" ]] && [[ -d "$state_dir" ]]; then
        log_info "Using existing state at $state_dir"
        return 0
    fi
    
    mkdir -p "$OUTPUT_DIR"
    
    if [[ -n "$STATE_URL" ]]; then
        log_info "Downloading pre-generated state from $STATE_URL..."
        mkdir -p "$state_dir"
        curl -fSL "$STATE_URL" | tar xz -C "$state_dir"
    else
        log_info "Generating state with stategen..."
        log_info "  Accounts: $ACCOUNTS"
        log_info "  Contracts: $CONTRACTS"
        log_info "  Storage slots: $MIN_SLOTS - $MAX_SLOTS per contract"
        log_info "  Distribution: $DISTRIBUTION"
        
        local seed_arg=""
        [[ -n "$SEED" ]] && seed_arg="--seed $SEED"

        local binary_trie_arg=""
        [[ "$BINARY_TRIE" == "true" ]] && binary_trie_arg="--binary-trie"

        # Run stategen in Docker
        docker run --rm \
            -v "$OUTPUT_DIR:/output" \
            stategen:latest \
            --db /output/chaindata \
            --accounts "$ACCOUNTS" \
            --contracts "$CONTRACTS" \
            --max-slots "$MAX_SLOTS" \
            --min-slots "$MIN_SLOTS" \
            --distribution "$DISTRIBUTION" \
            $seed_arg \
            $binary_trie_arg \
            --verbose
    fi
    
    log_info "State generation complete"
}

# Generate Kurtosis network config
generate_kurtosis_config() {
    local config_file="$OUTPUT_DIR/network-config.yaml"
    
    cat > "$config_file" << EOF
# Generated by launch-bloated-devnet.sh
# Ethereum devnet with pre-populated state

participants:
$(for i in $(seq 1 $GETH_NODES); do
cat << GETH
  - el_type: geth
    el_image: ethereum/client-go:latest
    cl_type: lighthouse
    cl_image: sigp/lighthouse:latest
    count: 1
    el_extra_params:
      - "--cache=4096"
      - "--txlookuplimit=0"$(if [[ "$BINARY_TRIE" == "true" ]]; then echo '
      - "--override.verkle=0"'; fi)
    el_volume_size: 100000  # 100GB
GETH
done)

network_params:
  network: kurtosis
  seconds_per_slot: 12
  genesis_delay: 20
  
  # Pre-funded accounts for testing
  prefunded_accounts:
    "0x878705ba3f8Bc32FCf7F4CAa1A35E72AF65CF766":
      balance: "1000000ETH"
    "0x4E9A3d9D1cd2A2b2371b8b3F489aE72259886f1A":
      balance: "1000000ETH"

additional_services:
  - dora
  - prometheus
  - grafana
EOF

    log_info "Generated Kurtosis config: $config_file"
    echo "$config_file"
}

# Create geth initialization script
create_geth_init_script() {
    local init_script="$OUTPUT_DIR/geth-init.sh"
    
    cat > "$init_script" << 'EOF'
#!/bin/bash
# Initialize geth with pre-populated state
set -e

CHAINDATA_SRC="/pregenerated-state/chaindata"
CHAINDATA_DST="/data/geth/execution-data/geth/chaindata"

if [[ -d "$CHAINDATA_SRC" ]] && [[ "$(ls -A $CHAINDATA_SRC 2>/dev/null)" ]]; then
    echo "Copying pre-generated state..."
    mkdir -p "$(dirname $CHAINDATA_DST)"
    cp -r "$CHAINDATA_SRC" "$CHAINDATA_DST"
    echo "Pre-generated state installed"
else
    echo "No pre-generated state found, starting fresh"
fi

# Execute original geth command
exec "$@"
EOF

    chmod +x "$init_script"
    log_info "Created geth init script: $init_script"
}

# Build custom geth image with state injection
build_geth_image() {
    local dockerfile="$OUTPUT_DIR/Dockerfile.geth"
    
    cat > "$dockerfile" << 'EOF'
FROM ethereum/client-go:latest

# Copy initialization script
COPY geth-init.sh /usr/local/bin/geth-init.sh
RUN chmod +x /usr/local/bin/geth-init.sh

# Pre-generated state will be mounted at /pregenerated-state
VOLUME ["/pregenerated-state"]

ENTRYPOINT ["/usr/local/bin/geth-init.sh"]
CMD ["geth"]
EOF

    log_info "Building custom geth image with state injection..."
    docker build -t geth-bloated:latest -f "$dockerfile" "$OUTPUT_DIR"
}

# Launch the devnet
launch_devnet() {
    local config_file="$1"
    
    log_info "Launching devnet with Kurtosis..."
    
    # Clean up any existing enclave
    kurtosis enclave rm -f bloated-devnet 2>/dev/null || true
    
    # Launch with ethereum-package
    kurtosis run \
        --enclave bloated-devnet \
        "$ETHEREUM_PACKAGE_PATH" \
        --args-file "$config_file"
    
    log_info "Devnet launched successfully!"
    log_info ""
    log_info "Useful commands:"
    log_info "  kurtosis enclave inspect bloated-devnet"
    log_info "  kurtosis enclave logs bloated-devnet"
    log_info "  kurtosis enclave stop bloated-devnet"
    log_info "  kurtosis enclave rm bloated-devnet"
}

# Main
main() {
    log_info "=== Bloated Devnet Launcher ==="
    
    check_deps
    prepare_state
    
    config_file=$(generate_kurtosis_config)
    create_geth_init_script
    
    # For manual state injection, use volumes approach
    log_info ""
    log_info "State prepared at: $OUTPUT_DIR/chaindata"
    log_info "Config generated at: $config_file"
    log_info ""
    log_info "To launch with pre-generated state, use the custom launcher or"
    log_info "mount the chaindata directory to the geth container."
    log_info ""
    
    read -p "Launch devnet now? [y/N] " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        launch_devnet "$config_file"
    fi
}

main "$@"
